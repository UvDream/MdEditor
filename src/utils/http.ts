// @ts-nocheck
// This file is generated by Umi automatically
// DO NOT CHANGE IT MANUALLY!
import axios, {type AxiosError, type AxiosInstance, type AxiosRequestConfig, type AxiosResponse,} from 'axios';
import useUmiRequest, {UseRequestProvider} from 'ahooks';
import {ApplyPluginsType} from 'umi';
import {getPluginManager} from '../core/plugin';

import {
    BaseOptions,
    BasePaginatedOptions,
    BaseResult,
    CombineService,
    LoadMoreFormatReturn,
    LoadMoreOptions,
    LoadMoreOptionsWithFormat,
    LoadMoreParams,
    LoadMoreResult,
    OptionsWithFormat,
    PaginatedFormatReturn,
    PaginatedOptionsWithFormat,
    PaginatedParams,
    PaginatedResult,
} from '/Users/wzj/Desktop/gateway/api/api-web/node_modules/.pnpm/@ahooksjs+use-request@2.8.15/node_modules/@ahooksjs/use-request/es/types';

type ResultWithData<T = any> = { data?: T; [key: string]: any };

function useRequest<R = any,
    P extends any[] = any,
    U = any,
    UU extends U = any,
    >(
    service: CombineService<R, P>,
    options: OptionsWithFormat<R, P, U, UU>,
): BaseResult<U, P>;
function useRequest<R extends ResultWithData = any, P extends any[] = any>(
    service: CombineService<R, P>,
    options?: BaseOptions<R['data'], P>,
): BaseResult<R['data'], P>;
function useRequest<R extends LoadMoreFormatReturn = any, RR = any>(
    service: CombineService<RR, LoadMoreParams<R>>,
    options: LoadMoreOptionsWithFormat<R, RR>,
): LoadMoreResult<R>;
function useRequest<R extends ResultWithData<LoadMoreFormatReturn | any> = any,
    RR extends R = any,
    >(
    service: CombineService<R, LoadMoreParams<R['data']>>,
    options: LoadMoreOptions<RR['data']>,
): LoadMoreResult<R['data']>;

function useRequest<R = any, Item = any, U extends Item = any>(
    service: CombineService<R, PaginatedParams>,
    options: PaginatedOptionsWithFormat<R, Item, U>,
): PaginatedResult<Item>;
function useRequest<Item = any, U extends Item = any>(
    service: CombineService<ResultWithData<PaginatedFormatReturn<Item>>,
        PaginatedParams>,
    options: BasePaginatedOptions<U>,
): PaginatedResult<Item>;
function useRequest(service: any, options: any = {}) {
    return useUmiRequest(service, {
        formatResult: result => result?.data,
        requestMethod: (requestOptions: any) => {
            if (typeof requestOptions === 'string') {
                return request(requestOptions);
            }
            if (typeof requestOptions === 'object') {
                const {url, ...rest} = requestOptions;
                return request(url, rest);
            }
            throw new Error('request options error');
        },
        ...options,
    });
}

// request 方法 opts 参数的接口
interface IRequestOptions extends AxiosRequestConfig {
    skipErrorHandler?: boolean;
    requestInterceptors?: IRequestInterceptorTuple[];
    responseInterceptors?: IResponseInterceptorTuple[];

    [key: string]: any;
}

interface IRequestOptionsWithResponse extends IRequestOptions {
    getResponse: true;
}

interface IRequestOptionsWithoutResponse extends IRequestOptions {
    getResponse: false;
}

interface IRequest {
    <T = any>(url: string, opts: IRequestOptionsWithResponse): Promise<AxiosResponse<T>>;

    <T = any>(url: string, opts: IRequestOptionsWithoutResponse): Promise<T>;

    <T = any>(url: string, opts: IRequestOptions): Promise<T>; // getResponse 默认是 false， 因此不提供该参数时，只返回 data
    <T = any>(url: string): Promise<T>;  // 不提供 opts 时，默认使用 'GET' method，并且默认返回 data
}

type RequestError = AxiosError | Error

interface IErrorHandler {
    (error: RequestError, opts: IRequestOptions): void;
}

type IRequestInterceptorAxios = (config: RequestOptions) => RequestOptions;
type IRequestInterceptorUmiRequest = (url: string, config: RequestOptions) => { url: string, options: RequestOptions };
type IRequestInterceptor = IRequestInterceptorAxios;
type IErrorInterceptor = (error: Error) => Promise<Error>;
type IResponseInterceptor = <T = any>(response: AxiosResponse<T>) => AxiosResponse<T>;
type IRequestInterceptorTuple = [IRequestInterceptor, IErrorInterceptor] | [IRequestInterceptor] | IRequestInterceptor
type IResponseInterceptorTuple =
    [IResponseInterceptor, IErrorInterceptor]
    | [IResponseInterceptor]
    | IResponseInterceptor

export interface RequestConfig<T = any> extends AxiosRequestConfig {
    errorConfig?: {
        errorHandler?: IErrorHandler;
        errorThrower?: (res: T) => void
    };
    requestInterceptors?: IRequestInterceptorTuple[];
    responseInterceptors?: IResponseInterceptorTuple[];
}

let requestInstance: AxiosInstance;
let config: RequestConfig;
const getConfig = (): RequestConfig => {
    if (config) return config;
    config = getPluginManager().applyPlugins({
        key: 'request',
        type: ApplyPluginsType.modify,
        initialValue: {},
    });
    return config;
};

const getRequestInstance = (): AxiosInstance => {
    if (requestInstance) return requestInstance;
    const config = getConfig();
    requestInstance = axios.create(config);

    config?.requestInterceptors?.forEach((interceptor) => {
        if (interceptor instanceof Array) {
            requestInstance.interceptors.request.use((config) => {
                const {url} = config;
                if (interceptor[0].length === 2) {
                    const {url: newUrl, options} = interceptor[0](url, config);
                    return {...options, url: newUrl};
                }
                return interceptor[0](config);
            }, interceptor[1]);
        } else {
            requestInstance.interceptors.request.use((config) => {
                const {url} = config;
                if (interceptor.length === 2) {
                    const {url: newUrl, options} = interceptor(url, config);
                    return {...options, url: newUrl};
                }
                return interceptor(config);
            })
        }
    });

    config?.responseInterceptors?.forEach((interceptor) => {
        interceptor instanceof Array ?
            requestInstance.interceptors.response.use(interceptor[0], interceptor[1]) :
            requestInstance.interceptors.response.use(interceptor);
    });

    // 当响应的数据 success 是 false 的时候，抛出 error 以供 errorHandler 处理。
    requestInstance.interceptors.response.use((response) => {
        const {data} = response;
        if (data?.success === false && config?.errorConfig?.errorThrower) {
            config.errorConfig.errorThrower(data);
        }
        return response;
    })
    return requestInstance;
};

const request: IRequest = (url: string, opts: any = {method: 'GET'}) => {
    config.headers["x-token"] = localStorage.getItem('token') || "token";
    let service = axios.create({
        baseURL: config.baseURL,
        timeout: config.timeout,
        headers: config.headers,
        withCredentials: config.withCredentials
    })
    return new Promise((resolve, reject) => {
        service.interceptors.request.use(config => {
            return config;
        }, error => {
            return Promise.reject(error);
        });
        service.interceptors.response.use(response => {
            let data;
            if (response.data == undefined) {
                data = response.request.responseText;
            } else {
                data = response.data;
            }
            switch (data.code) {
                case "110":
                    break;
                default:
            }
            return data;
        }, err => {
            if (err.response && err.response.status) {
                switch (err.response.status) {
                    case 400:
                        err.message = "请求错误";
                        break;
                    case 401:
                        err.message = "未授权，请登录";
                        break;
                    case 403:
                        err.message = "拒绝访问";
                        break;
                    case 404:
                        err.message = `请求地址出错: ${err.response.config.url}`;
                        break;
                    case 408:
                        err.message = "请求超时";
                        break;
                    case 500:
                        err.message = "服务器内部错误";

                        break;
                    case 501:
                        err.message = "服务未实现";
                        break;
                    case 502:
                        err.message = "网关错误";
                        break;
                    case 503:
                        err.message = "服务不可用";
                        break;
                    case 504:
                        err.message = "网关超时";
                        break;
                    case 505:
                        err.message = "HTTP版本不受支持";
                        break;
                    default:
                }
            }
            return Promise.reject(err); //返回错误信息
        })
        service(options).then(res => {
            resolve(res);
        }).catch(err => {
            reject(err);
        })
    })
}

export {
    useRequest,
    UseRequestProvider,
    request,
    getRequestInstance,
};

export type {
    AxiosInstance,
    AxiosRequestConfig,
    AxiosResponse,
    IResponseInterceptor as ResponseInterceptor,
    IRequestOptions as RequestOptions,
    IRequest as Request,
};
